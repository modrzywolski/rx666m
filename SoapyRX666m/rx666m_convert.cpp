/*
 * SoapySDR RX666m driver
 * Copyright (C) 2020 Marcin Odrzywolski <emk6@wp.pl>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include <iostream>
#include "LowLevel.hpp"
#include <chrono>
#include <csignal>
#include <cmath>
#include <fstream>
#include <boost/program_options/parsers.hpp>
#include <boost/program_options/options_description.hpp>
#include <boost/program_options/variables_map.hpp>
#include <boost/format.hpp>

typedef struct
{
	float real;
	float img;
}IQSample_t;

bool 		stopApp = false;

namespace po = boost::program_options;

void exitHandler( int signum )
{
	stopApp = true;
}


void playFile( std::istream& is)
{
	constexpr size_t		dataBufSize = 1024*1024;
	std::vector<uint16_t>	dataInBuf;
	std::vector<IQSample_t>	dataOutBuf;

	dataInBuf.reserve(dataBufSize);
	dataInBuf.resize(dataBufSize);
	dataOutBuf.reserve(dataBufSize);
	dataOutBuf.resize(dataBufSize);

	for (auto &e : dataOutBuf)
	{
		e.img = 0.0; //Direct sampling, no I signal
	}


	if(is.fail())
	{
		std::cerr << "Cannot open file\n";
		return;
	}

	while(!stopApp)
	{
		using namespace std::placeholders;

		size_t n = dataBufSize;
		is.read(reinterpret_cast<char*>(dataInBuf.data()), n * sizeof(uint16_t));
		if(!is)
		{
			n = is.gcount();
			is.clear();
			is.seekg(0); //rewind file
		}

		for (size_t i=0; i<n; ++i)
		{
			dataOutBuf[i].real = float(dataInBuf[i])/65536lu;
		}

		std::cout.write(reinterpret_cast<char*>(dataOutBuf.data()), n * sizeof(IQSample_t));
	}
}

int main(int ac, char *av[])
{
	po::options_description desc("RX666m command line conversion utility. Converts raw dumps generated by rx666m_util to IQ float32 stream. Reads from stdin, outputs data to stdout. Runs in infinite loop");
	desc.add_options()
		("help", "produce help message")
		("in",	po::value<std::string>(), "Input file with recorded samples")
		("stdin",	po::bool_switch(), "Read samples from stdin")
	;

	po::variables_map vm;
	po::store(po::parse_command_line(ac, av, desc), vm);
	po::notify(vm);

	if (vm.count("help") || (!vm.count("in") && !vm["stdin"].as< bool >()))
	{
		std::cerr << desc << "\n";
		return 1;
	}

	if(vm.count("in"))
	{
		std::ifstream is( vm["in"].as< std::string >().c_str(), std::ifstream::binary); 
		playFile( is );
	}
	else
	{
		playFile( std::cin );
	}

	return 0;
}
